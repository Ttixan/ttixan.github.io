# GAMES101 作业6相关问题整理

---

## 问题1：Renderer.cpp 的 Render() 实现

### 问题
需要将光线生成过程粘贴到 Render()，并按照新框架更新调用格式。

### 解决思路
- 按照新框架生成每个像素的主射线。
- 调用新的接口格式，获取颜色并写入帧缓冲区。

### 解决方法
- 参考作业5的光线生成过程，适配新框架。
- 对每个像素生成射线，调用 getIntersection 或相关接口，获取颜色。

**参考：**  
[Games101：作业6解析（含提高部分SAH）_games101作业6-CSDN博客](https://blog.csdn.net/Q_pril/article/details/124054123)

---

## 问题2：Triangle.hpp 的 getIntersection 实现

### 问题
需要将光线-三角形相交函数粘贴到 getIntersection，并更新相交信息格式。

### 解决思路
- 使用 Moller-Trumbore 算法实现光线与三角形的相交。
- 按照新框架返回 Intersection 信息。

### 解决方法
- 实现 getIntersection，计算交点并返回标准 Intersection 结构。

---

## 问题3：Bounds3.hpp 的 IntersectP 实现

### 问题
判断包围盒 BoundingBox 与光线是否相交。

### 解决思路
- 使用 slab 算法，分别计算 x/y/z 方向的进入和离开时间。
- 根据光线方向，决定最大最小值的计算方式（负方向时需要交换）。
- 判断 t_enter < t_exit 且 t_exit >= 0。

### 解决方法
- 计算 t_Min_x/y/z 和 t_Max_x/y/z。
- t_enter = max(t_Min_x, t_Min_y, t_Min_z)
- t_exit = min(t_Max_x, t_Max_y, t_Max_z)
- 返回 t_enter < t_exit 且 t_exit >= 0。

```cpp
float t_enter = std::max(t_Min_x, std::max(t_Min_y, t_Min_z));
float t_exit = std::min(t_Max_x, std::min(t_Max_y, t_Max_z));
return (t_enter < t_exit && t_exit >= 0);
```

---

## 问题4：BVH.cpp 的 getIntersection 实现

### 问题
递归遍历 BVH，利用包围盒加速求交过程。

### 解决思路
- 判断当前节点包围盒与光线是否相交。
- 若无交点，直接返回空 Intersection。
- 若为叶子节点，判断物体与光线是否相交。
- 若有左右子树，递归判断左右子树，返回距离最近的 Intersection。

### 解决方法
- 递归实现 getIntersection。
- 利用 Bounds3::IntersectP 判断包围盒与光线是否相交。
- 叶子节点直接调用物体的 getIntersection。
- 非叶子节点递归左右子树，返回最近交点。

```cpp
Intersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray& ray) const
{
    std::array<int, 3> dirIsNeg;
    dirIsNeg[0] = (ray.direction[0]>0);
    dirIsNeg[1] = (ray.direction[1]>0);
    dirIsNeg[2] = (ray.direction[2]>0);
    Intersection inter;
    if(!node->bounds.IntersectP(ray, ray.direction_inv, dirIsNeg)){
        return inter;
    }
    if(node->left == nullptr && node->right == nullptr){
        return node->object->getIntersection(ray);
    }
    Intersection l = getIntersection(node->left, ray);
    Intersection r = getIntersection(node->right, ray);
    return l.distance < r.distance ? l : r;
}
```

---

## 关键点解析

### dirIsNeg 的用法
- 光线方向为负时，需交换最大最小值，确保 slab 算法正确。

### t_enter 和 t_exit 的判断
- 需对所有 xyz 方向分别计算，再整体比较。

### BVH 递归条件
1. 包围盒无交点：直接返回空交点。
2. 包围盒有交点：
   - 叶子节点：判断物体与光线是否相交。
   - 非叶子节点：递归左右子树，返回最近交点。

---

**参考：**  
[Games101：作业6解析（含提高部分SAH）_games101作业6-CSDN博客](https://blog.csdn.net/Q_pril/article/details/124054123)
