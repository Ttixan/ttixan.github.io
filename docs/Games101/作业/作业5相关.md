# GAMES101 作业5相关问题整理

---

## 问题1：Renderer.cpp 的 Render() 实现

### 问题
需要为每个像素生成一条光线，调用 castRay() 得到颜色，并存储到帧缓冲区。

### 解决思路
1. 找到当前像素 (x, y) 的坐标。
2. 将像素坐标从栅格空间（raster space）转换到世界空间（world space）。
3. 生成从相机原点到像素中心的主射线。
4. 使用 castRay() 得到颜色。

### 解决方法
- 通过三步转换：raster space → NDC space → screen space → world space。
- 计算像素中心坐标，归一化并考虑宽高比和视场角。
- 生成射线并归一化方向，调用 castRay()。
- 将结果写入帧缓冲区，最终保存为图片。

**参考：**  
[Games101：作业5解析_games101作业5-CSDN博客](https://blog.csdn.net/Q_pril/article/details/123825665)  
[Generating Camera Rays with Ray-Tracing](https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays.html)

---

## 问题2：Triangle.hpp 的 rayTriangleIntersect() 实现

### 问题
需要实现三角形与射线的相交检测，更新 tnear, u, v 参数。

### 解决思路
- 使用 Moller-Trumbore 算法进行三角形与射线的相交计算。
- 只需带入公式即可。

### 解决方法
- 按照课上推导的 Moller-Trumbore 算法实现 rayTriangleIntersect()。
- 计算交点参数并判断是否相交。

**参考：**  
Lecture 13 Ray tracing 光线追踪 技术难题#Moller-Trumbore 算法  
[Games101：作业5解析_games101作业5-CSDN博客](https://blog.csdn.net/Q_pril/article/details/123825665)

---

## 难点解析

### 渲染过程与主射线生成

#### 问题
如何为每个像素生成主射线并转换坐标空间。

#### 解决思路
- 从相机原点出发，生成穿过像素中心的射线。
- 依次进行坐标空间转换：raster → NDC → screen → world。
- 考虑宽高比和视场角。

#### 解决方法
- 计算像素中心归一化坐标（NDC）。
- 映射到屏幕空间，调整 y 方向。
- 乘以宽高比和视场角缩放。
- 得到世界空间方向，归一化后用于 castRay。

**参考：**  
[Generating Camera Rays with Ray-Tracing](https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays.html)  
Lecture 5 and 6 Rasteriazation (Triangles)#定义屏幕空间(screen space)

---

## 代码示例

```cpp
void render(
    const Options &options,
    const std::vector<std::unique_ptr<Object>> &objects,
    const std::vector<std::unique_ptr<Light>> &lights)
{
    Matrix44f cameraToWorld;
    Vec3f *framebuffer = new Vec3f[options.width * options.height];
    Vec3f *pix = framebuffer;
    float scale = tan(deg2rad(options.fov * 0.5));
    float imageAspectRatio = options.width / (float)options.height;
    Vec3f orig;
    cameraToWorld.multVecMatrix(Vec3f(0), orig);
    for (uint32_t j = 0; j < options.height; ++j) {
        for (uint32_t i = 0; i < options.width; ++i) {
            // 1. 计算像素中心坐标并归一化
            // 2. 转换到屏幕空间，调整宽高比和视场角
            // 3. 生成主射线并归一化方向
            // 4. 调用 castRay 得到颜色
            float x = (2 * (i + 0.5) / (float)options.width) * imageAspectRatio * scale;
            float y = (1 - 2 * (j + 0.5) / (float)options.height) * scale;
            Vec3f dir;
            cameraToWorld.multDirMatrix(Vec3f(x, y, -1), dir);
            dir.normalize();
            *(pix++) = castRay(orig, dir, objects, lights, options, 0);
        }
    }

    // Save result to a PPM image (keep these flags if you compile under Windows)
    std::ofstream ofs("./out.ppm", std::ios::out | std::ios::binary);
    ofs << "P6\n" << options.width << " " << options.height << "\n255\n";
    for (uint32_t i = 0; i < options.height * options.width; ++i) {
        char r = (char)(255 * clamp(0, 1, framebuffer[i].x));
        char g = (char)(255 * clamp(0, 1, framebuffer[i].y));
        char b = (char)(255 * clamp(0, 1, framebuffer[i].z));
        ofs << r << g << b;
    }

    ofs.close();

    delete [] framebuffer;
}
    const Options &options,
    const std::vector<std::unique_ptr<Object>> &objects,
    const std::vector<std::unique_ptr<Light>> &lights)
{
    Matrix44f cameraToWorld;
    Vec3f *framebuffer = new Vec3f[options.width * options.height];
    Vec3f *pix = framebuffer;
    float scale = tan(deg2rad(options.fov * 0.5));
    float imageAspectRatio = options.width / (float)options.height;
    Vec3f orig;
    cameraToWorld.multVecMatrix(Vec3f(0), orig);
    for (uint32_t j = 0; j < options.height; ++j) {
        for (uint32_t i = 0; i < options.width; ++i) {
            float x = (2 * (i + 0.5) / (float)options.width) * imageAspectRatio * scale;
            float y = (1 - 2 * (j + 0.5) / (float)options.height) * scale;
            Vec3f dir;
            cameraToWorld.multDirMatrix(Vec3f(x, y, -1), dir);
            dir.normalize();
            *(pix++) = castRay(orig, dir, objects, lights, options, 0);
        }
    }

    // Save result to a PPM image (keep these flags if you compile under Windows)
    std::ofstream ofs("./out.ppm", std::ios::out | std::ios::binary);
    ofs << "P6\n" << options.width << " " << options.height << "\n255\n";
    for (uint32_t i = 0; i < options.height * options.width; ++i) {
        char r = (char)(255 * clamp(0, 1, framebuffer[i].x));
        char g = (char)(255 * clamp(0, 1, framebuffer[i].y));
        char b = (char)(255 * clamp(0, 1, framebuffer[i].z));
        ofs << r << g << b;
    }

    ofs.close();

    delete [] framebuffer;
}
```
